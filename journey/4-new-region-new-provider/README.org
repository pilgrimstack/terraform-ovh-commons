#+TITLE: A journey with Terraform on OVH Cloud (part 3)
#+AUTHOR: yann degat
#+EMAIL: yann.degat@corp.ovh.com

* Objective

This document is the third part of a [[../0-simple-terraform/README.md][step by step guide]] on how to use 
the [[https://terraform.io][Hashicorp Terraform]] tool with [[https://www.ovh.com/fr/public-cloud/instances/][OVH Cloud]]. It will help you create 
an openstack swift container on the region of your choice, but this
time by introducing terraform state management and terraform workspaces.


* Pre requisites

Please refer to the pre requisites paragraph of the [[../0-simple-terraform/README.md][first part]] of this guide.

Build your blog on whatever techno you like. As this is not the main purpose of 
this tutorial, we'll provide you a simple static blog content generated with 
[[https://gohugo.io/getting-started/quick-start/][hugo]], a popular static website generator.

First follow the getting started guide to install hugo on your system.
Then generate a website with some content

#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
curl -Lo /tmp/example.zip https://github.com/Xzya/hugo-material-blog/archive/master.zip
unzip /tmp/example.zip -d /tmp
mv /tmp/hugo-material-blog-master/exampleSite ./www
mkdir ./www/themes
mv /tmp/hugo-material-blog-master ./www/themes/hugo-material-blog
#+END_SRC

You can edit/remove/add some content, then generate your site 

#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
cd www && hugo
#+END_SRC

Your webiste has been generated in the `www/public` directory

NB: you can preview your site by serving files with hugo:

#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
hugo server -b 0.0.0.0 -p 8080 -s www
#+END_SRC

* install custom providers

** install acme provider


#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
mkdir -p ~/.terraform.d/plugins
curl -Lo /tmp/terraform-provider-acme.zip \
 https://github.com/vancluever/terraform-provider-acme/releases/download/v1.0.0/terraform-provider-acme_v1.0.0_linux_amd64.zip
unzip  /tmp/terraform-provider-acme.zip -d /tmp
mv /tmp/terraform-provider-acme ~/.terraform.d/plugins
#+END_SRC

* In pratice: Terraform ???


Configure terraform providers and state storage

#+BEGIN_SRC terraform :eval never-export :tangle main.tf
terraform {
  backend "swift" {
    container = "demo-remote-state"
  }
}

provider "ovh" {
  #  version  = "~> 0.3"
  endpoint = "ovh-eu"
}

provider "openstack" {
  version     = "= 1.5"
  region      = "${var.region_a}"
  alias = "region_a"
}

provider "openstack" {
  version     = "= 1.5"
  region      = "${var.region_b}"

  alias = "region_b"
}
#+END_SRC

Vars & outputs remains just as before:

#+BEGIN_SRC terraform :eval never-export :tangle variables.tf
variable "region_a" {
  description = "The id of the first openstack region"
  default = "DE1"
}

variable "region_b" {
  description = "The id of the second openstack region"
  default = "WAW1"
}

variable "name" {
  description = "name of blog. Used to forge subdomain"
  default = "myblog"
}

variable "ssh_public_key" {
  description = "The path of the ssh public key that will be used by ansible to provision the hosts"
  default     = "~/.ssh/id_rsa.pub"
}

variable "flavor_name" {
  description = "flavor name of nodes."
  default     = "s1-2"
}

variable "count" {
  description = "number of blog nodes per region"
  default     = 1
}

variable "zone" {
  description = "the domain root zone"
}

variable "email" {
  description = "email for letsencrypt registration"
}

#+END_SRC


Generate lets encrypt certificate

#+BEGIN_SRC terraform :eval never-export :tangle main.tf
# letsencrypt acme challenge
# Create the private key for the registration (not the certificate)
resource "tls_private_key" "private_key" {
  algorithm = "RSA"
}

# Set up a registration using a private key from tls_private_key
resource "acme_registration" "reg" {
  server_url      = "https://acme-v01.api.letsencrypt.org/directory"
  account_key_pem = "${tls_private_key.private_key.private_key_pem}"
  email_address   = "${var.email}"
}

# Create a certificate
resource "acme_certificate" "certificate" {
  server_url      = "https://acme-v01.api.letsencrypt.org/directory"
  account_key_pem = "${tls_private_key.private_key.private_key_pem}"
  common_name     = "${var.name}.${var.zone}"

  dns_challenge {
    provider = "ovh"
  }

  registration_url = "${acme_registration.reg.id}"
}
#+END_SRC


Create the ports on Ext net to get public ips for your nodes

#+BEGIN_SRC terraform :eval never-export :tangle main.tf
data "openstack_networking_network_v2" "public_a" {
  name     = "Ext-Net"
  provider = "openstack.region_a"
}

resource "openstack_networking_port_v2" "public_a" {
  count          = "${var.count}"
  name           = "${var.name}_a_${count.index}"
  network_id     = "${data.openstack_networking_network_v2.public_a.id}"
  admin_state_up = "true"
  provider       = "openstack.region_a"
}

data "openstack_networking_network_v2" "public_b" {
  name     = "Ext-Net"
  provider = "openstack.region_b"
}

resource "openstack_networking_port_v2" "public_b" {
  count          = "${var.count}"
  name           = "${var.name}_b_${count.index}"
  network_id     = "${data.openstack_networking_network_v2.public_b.id}"
  admin_state_up = "true"
  provider       = "openstack.region_b"
}
#+END_SRC

Then create the nodes:

#+BEGIN_SRC terraform :eval never-export :tangle main.tf
data "http" "myip" {
  url = "https://api.ipify.org"
}

resource "openstack_compute_keypair_v2" "keypair_a" {
  name       = "${var.name}"
  public_key = "${file(var.ssh_public_key)}"
  provider   = "openstack.region_a"
}

resource "openstack_compute_keypair_v2" "keypair_b" {
  name       = "${var.name}"
  public_key = "${file(var.ssh_public_key)}"
  provider   = "openstack.region_b"
}

data "template_file" "setup" {
  template = <<SETUP
#!/bin/bash

# install softwares & depencencies
apt update -y && apt install -y ufw apache2

# setup firewall
ufw default deny
ufw allow in on ens3 proto tcp from 0.0.0.0/0 to 0.0.0.0/0 port 80
ufw allow in on ens3 proto tcp from 0.0.0.0/0 to 0.0.0.0/0 port 443
ufw allow in on ens3 proto tcp from ${trimspace(data.http.myip.body)}/32 to 0.0.0.0/0 port 22
ufw enable

# setup apache2
cp /tmp/setup/myblog.conf /etc/apache2/sites-available/
cp /tmp/setup/ports.conf /etc/apache2
a2enmod ssl
a2enmod rewrite
a2ensite myblog
a2dissite 000-default

# setup systemd services
systemctl enable apache2 ufw
systemctl restart apache2 ufw
SETUP
}

data "template_file" "myblog_conf" {
  template = "${file("${path.module}/myblog.conf.tpl")}"

  vars {
    server_name = "${var.name}.${var.zone}"
  }
}

data "template_file" "userdata" {
  template = <<CLOUDCONFIG
#cloud-config

write_files:
  - path: /etc/letsencrypt/cert.pem
    permissions: '0600'
    content: |
      ${indent(6, acme_certificate.certificate.certificate_pem)}
  - path: /etc/letsencrypt/key.pem
    permissions: '0600'
    content: |
      ${indent(6, acme_certificate.certificate.private_key_pem)}
  - path: /etc/letsencrypt/issuer.pem
    permissions: '0600'
    content: |
      ${indent(6, acme_certificate.certificate.issuer_pem)}
  - path: /tmp/setup/run.sh
    permissions: '0755'
    content: |
      ${indent(6, data.template_file.setup.rendered)}
  - path: /tmp/setup/myblog.conf
    permissions: '0644'
    content: |
      ${indent(6, data.template_file.myblog_conf.rendered)}
  - path: /tmp/setup/ports.conf
    permissions: '0644'
    content: |
      # If you just change the port or add more ports here, you will likely also
      # have to change the VirtualHost statement in
      # /etc/apache2/sites-enabled/000-default.conf
      Listen 80
      <IfModule ssl_module>
           Listen 0.0.0.0:443
      </IfModule>
      <IfModule mod_gnutls.c>
           Listen 0.0.0.0:443
      </IfModule>
      # vim: syntax=apache ts=4 sw=4 sts=4 sr noet

  - path: /etc/systemd/network/30-ens3.network
    permissions: '0644'
    content: |
      [Match]
      Name=ens3
      [Network]
      DHCP=ipv4

runcmd:
   - /tmp/setup/run.sh
CLOUDCONFIG
}

resource "openstack_compute_instance_v2" "nodes_a" {
  count       = "${var.count}"
  name        = "${var.name}_a_${count.index}"
  image_name  = "Ubuntu 18.04"
  flavor_name = "${var.flavor_name}"
  key_pair    = "${openstack_compute_keypair_v2.keypair_a.name}"
  user_data   = "${data.template_file.userdata.rendered}"

  network {
    access_network = true
    port           = "${openstack_networking_port_v2.public_a.*.id[count.index]}"
  }

  provider = "openstack.region_a"
}

resource "openstack_compute_instance_v2" "nodes_b" {
  count       = "${var.count}"
  name        = "${var.name}_b_${count.index}"
  image_name  = "Ubuntu 18.04"
  flavor_name = "${var.flavor_name}"
  key_pair    = "${openstack_compute_keypair_v2.keypair_b.name}"
  user_data   = "${data.template_file.userdata.rendered}"

  network {
    access_network = true
    port           = "${openstack_networking_port_v2.public_b.*.id[count.index]}"
  }
  
  provider = "openstack.region_b"
}
#+END_SRC

Great, now upload the website contents

#+BEGIN_SRC terraform :eval never-export :tangle main.tf
resource "null_resource" "provision_a" {
  count = "${var.count}"

  triggers {
    id = "${openstack_compute_instance_v2.nodes_a.*.id[count.index]}"
  }

  connection {
    host = "${openstack_compute_instance_v2.nodes_a.*.access_ip_v4[count.index]}"
    user = "ubuntu"
  }

  provisioner "file" {
    source      = "./www/public"
    destination = "/home/ubuntu/${var.name}"
  }
}

resource "null_resource" "provision_b" {
  count = "${var.count}"

  triggers {
    id = "${openstack_compute_instance_v2.nodes_b.*.id[count.index]}"
  }

  connection {
    host = "${openstack_compute_instance_v2.nodes_b.*.access_ip_v4[count.index]}"
    user = "ubuntu"
  }

  provisioner "file" {
    source      = "./www/public"
    destination = "/home/ubuntu/${var.name}"
  }
}
#+END_SRC

#+BEGIN_SRC terraform :eval never-export :tangle main.tf
# setup subdomain
data "ovh_domain_zone" "rootzone" {
  name = "${var.zone}"
}

# trick to filter ipv6 addrs 
data "template_file" "ipv4_addr_a" {
  count    = "${var.count}"
  template = "${element(compact(split(",", replace(join(",", flatten(openstack_networking_port_v2.public_a.*.all_fixed_ips)), "/[[:alnum:]]+:[^,]+/", ""))), count.index)}"
}

data "template_file" "ipv4_addr_b" {
  count    = "${var.count}"
  template = "${element(compact(split(",", replace(join(",", flatten(openstack_networking_port_v2.public_b.*.all_fixed_ips)), "/[[:alnum:]]+:[^,]+/", ""))), count.index)}"
}

resource "ovh_domain_zone_record" "subdomain_records_a" {
  count     = "${var.count}"
  zone      = "${data.ovh_domain_zone.rootzone.name}"
  subdomain = "${var.name}"
  fieldtype = "A"
  target    = "${data.template_file.ipv4_addr_a.*.rendered[count.index]}"
}

resource "ovh_domain_zone_record" "subdomain_records_b" {
  count     = "${var.count}"
  zone      = "${data.ovh_domain_zone.rootzone.name}"
  subdomain = "${var.name}"
  fieldtype = "A"
  target    = "${data.template_file.ipv4_addr_b.*.rendered[count.index]}"
}
#+END_SRC

then run terraform init:

#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
source ~/openrc.sh
terraform init
#+END_SRC

#+BEGIN_EXAMPLE bash
Initializing the backend...

Successfully configured the backend "swift"! Terraform will automatically
use this backend unless the backend configuration changes.
...
#+END_EXAMPLE  

Alright. Now let's apply the script as usual:
#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
source ~/openrc.sh
terraform apply -auto-approve
...
#+END_SRC

And look at the directory structure:
#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
ls 
#+END_SRC

#+BEGIN_EXAMPLE bash
main.tf  Makefile  outputs.tf  README.org  variables.tf
#+END_EXAMPLE  

No ~tfstate~ file! Where could it be? Well it should be present in a swift container
as defined in the ~tf~ file. So lets check this:

#+BEGIN_SRC bash :session *journey* :results output pp  :eval never-export
openstack container list
openstack object list demo-remote-state
#+END_SRC

#+BEGIN_EXAMPLE bash
+-------------------------------+
| Name                          |
+-------------------------------+
| demo-remote-state             |
+-------------------------------+
+------------+
| Name       |
+------------+
| tfstate.tf |
+------------+
#+END_EXAMPLE  

Right where it should be. This means that anyone running the same script on another
machine with credentials accessing the same project on the same openstack region
should have access to this ~tfstate~ file.

Notice: terraform maintains a local copy of this file in the ~.terraform~ directory.

* Workspaces

Terraform also allows you to manage your environments with the `workspaces` feature.
You can easily switch from one environment to the other by a simple command.

* Going Further

We're finished with terraform basics on OVH. Now we'll go deeper into bootstrapping 
real infrastructure, starting with a public cloud virtual machine.

See you on [[../3-simple-public-instance/README.md][the fourth step]] of our journey.
